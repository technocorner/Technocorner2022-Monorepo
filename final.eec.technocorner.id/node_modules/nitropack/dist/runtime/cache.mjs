import { hash } from "ohash";
import { toEventHandler, handleCacheHeaders } from "h3";
import { useStorage } from "#nitro";
const defaultCacheOptions = {
  name: "_",
  base: "/cache",
  swr: true,
  magAge: 1
};
export function defineCachedFunction(fn, opts) {
  opts = { ...defaultCacheOptions, ...opts };
  const pending = {};
  const group = opts.group || "nitro";
  const name = opts.name || fn.name || "_";
  const integrity = hash([opts.integrity, fn, opts]);
  async function get(key, resolver) {
    const cacheKey = [opts.base, group, name, key].filter(Boolean).join(":");
    const entry = await useStorage().getItem(cacheKey) || {};
    const ttl = (opts.magAge ?? opts.magAge ?? 0) * 1e3;
    if (ttl) {
      entry.expires = Date.now() + ttl;
    }
    const expired = entry.integrity !== integrity || ttl && Date.now() - (entry.mtime || 0) > ttl;
    const _resolve = async () => {
      if (!pending[key]) {
        pending[key] = Promise.resolve(resolver());
      }
      entry.value = await pending[key];
      entry.mtime = Date.now();
      entry.integrity = integrity;
      delete pending[key];
      useStorage().setItem(cacheKey, entry).catch((error) => console.error("[nitro] [cache]", error));
    };
    const _resolvePromise = expired ? _resolve() : Promise.resolve();
    if (opts.swr && entry.value) {
      _resolvePromise.catch(console.error);
      return Promise.resolve(entry);
    }
    return _resolvePromise.then(() => entry);
  }
  return async (...args) => {
    const key = (opts.getKey || getKey)(...args);
    const entry = await get(key, () => fn(...args));
    let value = entry.value;
    if (opts.transform) {
      value = await opts.transform(entry, ...args) || value;
    }
    return value;
  };
}
export const cachedFunction = defineCachedFunction;
function getKey(...args) {
  return args.length ? hash(args, {}) : "";
}
export function defineCachedEventHandler(handler, opts = defaultCacheOptions) {
  const _opts = {
    ...opts,
    getKey: (req) => req.originalUrl || req.url,
    group: opts.group || "nitro/handlers",
    integrity: [
      opts.integrity,
      handler
    ],
    transform(entry, event) {
      if (event.res.headersSent) {
        return;
      }
      if (handleCacheHeaders(event, {
        modifiedTime: new Date(entry.mtime),
        etag: `W/"${hash(entry.value)}"`,
        maxAge: opts.magAge
      })) {
        return;
      }
      for (const header in entry.value.headers) {
        event.res.setHeader(header, entry.value.headers[header]);
      }
      const cacheControl = [];
      if (opts.swr) {
        if (opts.magAge) {
          cacheControl.push(`s-maxage=${opts.magAge / 1e3}`);
        }
        cacheControl.push("stale-while-revalidate");
      } else if (opts.magAge) {
        cacheControl.push(`max-age=${opts.magAge / 1e3}`);
      }
      if (cacheControl.length) {
        event.res.setHeader("Cache-Control", cacheControl.join(", "));
      }
      if (entry.value.code) {
        event.res.statusCode = entry.value.code;
      }
      return entry.value.body;
    }
  };
  const _handler = toEventHandler(handler);
  return cachedFunction(async (event) => {
    const body = await _handler(event);
    const headers = event.res.getHeaders();
    const cacheEntry = {
      code: event.res.statusCode,
      headers,
      body
    };
    return cacheEntry;
  }, _opts);
}
export const cachedEventHandler = defineCachedEventHandler;
